---
title: APT-Q-31(海莲花)时间线及攻击手法总结
date: 2023-06-14 17:00:06
tags:
categories: 
- APT研究
- APT-Q-31(海莲花) 
Password:  APT-Q-31(海莲花)时间线及攻击手法总结
---



# 概述

| 团伙名称     | 海莲花                                                   |
| ------------ | -------------------------------------------------------- |
| 攻击者类型   | 国家背景组织                                             |
| 技术能力     | 中                                                       |
| 疑似来源     | 越南                                                     |
| 最早活动时间 | 2012年                                                   |
| 影响行业     | 政府、科研院所、海事机构、海域建设、航运企业             |
| 别名         | OceanLotus, APT32, Cobalt  Kitty, APT - C - 00, SeaLotus |
| 攻击方式     | 鱼叉攻击、水坑攻击                                       |
| 攻击频率     | 高                                                       |
| 最近活动时间 | 2022年                                                   |
| 常用语言     | 英语、越南语、简体中文                                   |



海莲花（OceanLotus）是一个据称东南亚背景的APT组织。该组织最早于2015年5月被天眼实验室（现红雨滴团队）披露并命名，其攻击活动最早可追溯到2012 年4月，攻击目标包括人权代表、异见人士、媒体、银行、海事机构、海域建设部门、科研院所和航运企业，后扩展到几乎所有重要的组织机构，受害区域涉及东亚、东南亚、欧洲等地区，持续活跃至今。从2020年中开始海莲花组织逐渐放弃了基于鱼叉邮件的投递方式，开始通过渗透的手段对高价值目标进行攻击活动，这意味着出现在大众视野范围内的海莲花将会大幅度减少。但历史告诉我们，看不见的敌人才是最危险的，那些尚未被发现的APT攻击，才应该是我们研究的重点。
本文将对部分出现在VirusTotal上的海莲花后渗透阶段释放cs远控的各类白加黑组件进行分析和总结。

# 技战法

该组织拥有非常高的社会工程学技巧，并且常用鱼叉攻击和水坑攻击，并且会利用和修改公开的攻击工具和开源项目。常用PowerShell脚本、COM scriptlets，恶意代码使用C++编写，也有C#编写的恶意代码。

 相关攻击战术： 1. 邮件鱼叉攻击，附带包括伪装成文档的PE文件、HTA文件、MHT文件

 2. 水坑攻击，在水坑网站植入webshell后门，并且webshell使用Javascript，并控制失陷域名运行两套不同的Javascript框架，用来跟踪和辨识目标受害者 3. 使用Cobalt Strike结合PowerShell脚本实现在内网的横向移动 4. 会在发起攻击前收集攻击目标的信息，并长期跟踪相关热点新闻事件 相关攻击技术： 1. 利用知名官方应用的名称、路径实现恶意模块的运行和躲避检测，如QQ 2. 利用官方应用的DLL劫持技术 3. 在HTTP协议头部的Host字段填充官方域名，并在cookie字段传输加密的内容 4. 使用Safebrowsing Beacon 5. DNS Tunneling 6. 计划任务执行恶意载荷，恶意载荷通常以图片格式下载 7. 常用PowerShell，并利用Invoke-Obfuscation实现混淆 8. 将恶意载荷伪装成常用软件更新或安装程序 9. 使用Outlook宏实现CC后门，其替换VbaProject.OTM为恶意宏 10. 该组织常用的木马被称为Denis木马

## 后渗透白加黑

### 样本分析

从shellcode的存放位置来讲，可以大体将海莲花白加黑组件分为shellcode在资源和shellcode硬编码在数据段。而从shellcode的加载方式来讲，可以将其分为：不依赖外部文件直接自解密、获取当前主机信息作为密钥解密shellcode、读取外部文件解密shellcode、进程注入加载shellcode等几类。下文将分别对这几类样本进行分析。

### shellcode硬编码

#### 获取主机信息解密类

此类样本入口点代码如下，关键函数在DllMain末尾的函数中，

![](APT-Q-31(海莲花)时间线及攻击手法总结/1.png)

该函数内部会执行一个call调用，push 0 之后直接调用ExitProcess结束进程



被调用的这个函数将会先创建一个互斥体进行多开检测，互斥体的命名格式为，该互斥体名通常由上一段shellcode获取计算机用户名并转换生成：

Local{XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX}，互斥体创建完成之后，程序将会VirtualAlloc分配一段内存空间并在将一段硬编码在程序中的数据拷贝过来，最终通过call esi的方式跳转到新开辟的内存空间中执行。

![](APT-Q-31(海莲花)时间线及攻击手法总结/2.png)



hellcode如下，这类样本的shellcode仅需动态获取API地址即可，不用再自解密自身。

![](APT-Q-31(海莲花)时间线及攻击手法总结/3.png)

大多数情况下，这段shellcode也是一个加载器，它会尝试获取当前主机的一些信息以解密后续的payload，这取决于上一阶段的样本向C2发送了哪种类型的信息hash值以生成加密的数据。常见的信息类型为计算机名、用户名、ip地址等。

![](APT-Q-31(海莲花)时间线及攻击手法总结/4.png)

程序以相同的逻辑获取当前主机的信息，计算hash并尝试用该hash进行解密，这是一种较为有效的反分析手法，可以确保程序不会在非预期的环境下运行

![](APT-Q-31(海莲花)时间线及攻击手法总结/5.png)



待解密的数据也以硬编码的形式存储在原始文件的data段中

![](APT-Q-31(海莲花)时间线及攻击手法总结/6.png)

若程序解密成功，则创建线程执行解密之后的shellcode

![](APT-Q-31(海莲花)时间线及攻击手法总结/7.png)

#### 自解密类

在另外一种情况下，攻击者可能会在加载硬编码的shellcode之前获取当前dll的调用进程名并与预定义的进程名做比较来实现简单的环境检测

![](APT-Q-31(海莲花)时间线及攻击手法总结/8.png)

而这个版本硬编码的shellcode将会动态解密自身

![](APT-Q-31(海莲花)时间线及攻击手法总结/9.png)

循环自解密之后，程序动态获取API地址，然后通过VirtualAlloc分配新的内存空间之后填充另外一段shellcode加载执行。加载的代码为CobaltStrike的payload

#### 释放白加黑组件类

而在某些情况下，硬编码的shellcode可能是如下形式：

![](APT-Q-31(海莲花)时间线及攻击手法总结/10.png)

此类样本主要是起到一个文件拷贝功能，程序会将当前目录下一组白加黑的样本拷贝到%temp%目录下并启动白exe以加载恶意dll。

![](APT-Q-31(海莲花)时间线及攻击手法总结/11.png)

拷贝利用的黑dll

![](APT-Q-31(海莲花)时间线及攻击手法总结/12.png)

设置计划任务用于启动%temp%目录下的wps.exe

### shellcode在资源

#### 获取主机信息解密类

此类样本和上述样本在解密方式上保持一致，均为获取受害者主机上的基本信息生成key进行解密。但不同的是此类样本的shellcode并没有硬编码到数据段，而是藏在了资源中。样本在dllMain进来依旧是先创建一个海莲花风格的互斥体，然后在执行一段无实际意义的代码之后读取资源并创建线程执行资源的shellcode。

![](APT-Q-31(海莲花)时间线及攻击手法总结/13.png)

此类样本读取资源之后将会直接加载，在shellcode中动态解密自身。

![](APT-Q-31(海莲花)时间线及攻击手法总结/14.png)

资源shellcode会通过多个循环动态解密自身

![](APT-Q-31(海莲花)时间线及攻击手法总结/15.png)

解密完成之后通常会出现如下格式的代码，一般情况下，call执行的代码主要是用于动态获取API地址，jmp跳转过去的代码才是真实的功能代码

![](APT-Q-31(海莲花)时间线及攻击手法总结/16.png)

和类别一的解密逻辑相同，此类样本最终通过获取的信息生成key然后尝试用该key进行解密，若解密成功创建线程执行解密后的shellcode

![](APT-Q-31(海莲花)时间线及攻击手法总结/17.png)

#### **读取文件解密类**

除了获取上一阶段的主机信息以解密shellcode，海莲花有时候还会通过读取特定的外部文件进行解密。
原始样本为dll，依旧是白利用的方式加载名为InitLPUHelper的导出函数

![](APT-Q-31(海莲花)时间线及攻击手法总结/18.png)



在ExitProcess之前的函数调用，会读取当前的资源文件并将其拷贝到VirtualAlloc分配的新内存空间中，通过call edi的方式加载shellcode。

![](APT-Q-31(海莲花)时间线及攻击手法总结/19.png)



shellcode入口点是熟悉的自解密代码，代码会动态循环解密自身加载链接库和获取API地址

![](APT-Q-31(海莲花)时间线及攻击手法总结/20.png)

尝试打开%Temp% 路径下的.tmp文件

若文件打开失败，程序则判定当前的环境不符合预期，从而退出运行。

#### **进程注入类**

此类样本主要通过进程注入实现shellcode的加载， 外层的loader大同小异，只是少数样本会将关键call藏到某个导出函数中而不再是dllMain

![](APT-Q-31(海莲花)时间线及攻击手法总结/21.png)

该段shellcode执行之后会动态获取一些API的地址并调用

![](APT-Q-31(海莲花)时间线及攻击手法总结/22.png)



创建一个svchost.exe进程用于注入

![](APT-Q-31(海莲花)时间线及攻击手法总结/23.png)

最终，程序尝试在刚才启动的进程中进行注入

![](APT-Q-31(海莲花)时间线及攻击手法总结/24.png)

此样本分配的空间为0x90000,将shellcode写入到svchost的内存中,写入的代码为海莲花的常用自解密shellcode,最终创建远线程加载shellcode

















